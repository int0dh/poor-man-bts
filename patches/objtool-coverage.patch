commit cac4b424dc36f45ec9b6124ec43dc9cebf3343b6
Author: Pavel Boldin <boldin.pavel@gmail.com>
Date:   Thu Aug 30 23:40:10 2018 +0300

    objtool coverage PoC
    
    Signed-off-by: Pavel Boldin <boldin.pavel@gmail.com>

diff --git a/tools/objtool/Build b/tools/objtool/Build
index 749becd..e187893 100644
--- a/tools/objtool/Build
+++ b/tools/objtool/Build
@@ -1,7 +1,9 @@
 objtool-y += arch/$(SRCARCH)/
 objtool-y += builtin-check.o
+objtool-y += builtin-coverage.o
 objtool-y += builtin-orc.o
 objtool-y += check.o
+objtool-y += coverage.o
 objtool-y += orc_gen.o
 objtool-y += orc_dump.o
 objtool-y += elf.o
diff --git a/tools/objtool/arch.h b/tools/objtool/arch.h
index b0d7dc3..3d62e05 100644
--- a/tools/objtool/arch.h
+++ b/tools/objtool/arch.h
@@ -70,12 +70,24 @@ struct stack_op {
 	struct op_src src;
 };
 
+#define JUMP_OP_OPCODE_DYNAMIC	0xff
+#define JUMP_OP_DYNAMIC_REG_REF	0x80
+struct jump_op {
+	unsigned char opcode; /* 0xff for dynamic jump */
+
+	unsigned char dynamic_reg; /* has 0x80 for memref */
+	unsigned char dynamic_sib_mult; /* zero for no sib */
+	unsigned char dynamic_sib_reg;
+	unsigned int dynamic_disp32;
+};
+
 void arch_initial_func_cfi_state(struct cfi_state *state);
 
 int arch_decode_instruction(struct elf *elf, struct section *sec,
 			    unsigned long offset, unsigned int maxlen,
 			    unsigned int *len, unsigned char *type,
-			    unsigned long *immediate, struct stack_op *op);
+			    unsigned long *immediate, struct jump_op *jcc,
+			    struct stack_op *op);
 
 bool arch_callee_saved_reg(unsigned char reg);
 
diff --git a/tools/objtool/arch/x86/decode.c b/tools/objtool/arch/x86/decode.c
index 540a209..97db0f3 100644
--- a/tools/objtool/arch/x86/decode.c
+++ b/tools/objtool/arch/x86/decode.c
@@ -81,7 +81,8 @@ bool arch_callee_saved_reg(unsigned char reg)
 int arch_decode_instruction(struct elf *elf, struct section *sec,
 			    unsigned long offset, unsigned int maxlen,
 			    unsigned int *len, unsigned char *type,
-			    unsigned long *immediate, struct stack_op *op)
+			    unsigned long *immediate, struct jump_op *jcc,
+			    struct stack_op *op)
 {
 	struct insn insn;
 	int x86_64, sign;
@@ -173,6 +174,7 @@ int arch_decode_instruction(struct elf *elf, struct section *sec,
 
 	case 0x70 ... 0x7f:
 		*type = INSN_JUMP_CONDITIONAL;
+		jcc->opcode = op1;
 		break;
 
 	case 0x81:
@@ -372,6 +374,7 @@ int arch_decode_instruction(struct elf *elf, struct section *sec,
 		if (op2 >= 0x80 && op2 <= 0x8f) {
 
 			*type = INSN_JUMP_CONDITIONAL;
+			jcc->opcode = op2 - 0x10;
 
 		} else if (op2 == 0x05 || op2 == 0x07 || op2 == 0x34 ||
 			   op2 == 0x35) {
@@ -422,11 +425,13 @@ int arch_decode_instruction(struct elf *elf, struct section *sec,
 	case 0xe3:
 		/* jecxz/jrcxz */
 		*type = INSN_JUMP_CONDITIONAL;
+		jcc->opcode = op1;
 		break;
 
 	case 0xe9:
 	case 0xeb:
 		*type = INSN_JUMP_UNCONDITIONAL;
+		jcc->opcode = op1;
 		break;
 
 	case 0xc2:
@@ -449,11 +454,27 @@ int arch_decode_instruction(struct elf *elf, struct section *sec,
 
 			*type = INSN_CALL_DYNAMIC;
 
-		else if (modrm_reg == 4)
+		else if (modrm_reg == 4) {
 
 			*type = INSN_JUMP_DYNAMIC;
+			jcc->opcode = op1;
+			jcc->dynamic_reg = modrm_rm + (rex_b << 3);
+
+			if (modrm_mod != 0x3) { /* is mem ref */
+				if (modrm_mod == 0 && modrm_rm == 0x5) { /* is RIP relative */
+					jcc->dynamic_reg = 0x20;
+				} else if (modrm_rm == 0x4) { /* is sib ref */
+					jcc->dynamic_reg = X86_SIB_BASE(sib) + (rex_b << 3);
+					jcc->dynamic_sib_reg  = X86_SIB_INDEX(sib) + (rex_x << 3);
+					jcc->dynamic_sib_mult = 1 << X86_SIB_SCALE(sib);
+				}
+
+				jcc->dynamic_reg |= JUMP_OP_DYNAMIC_REG_REF;
+			}
+
+			jcc->dynamic_disp32 = insn.displacement.value;
 
-		else if (modrm_reg == 5)
+		} else if (modrm_reg == 5)
 
 			/* jmpf */
 			*type = INSN_CONTEXT_SWITCH;
diff --git a/tools/objtool/builtin-check.c b/tools/objtool/builtin-check.c
index 694abc6..c9dd928 100644
--- a/tools/objtool/builtin-check.c
+++ b/tools/objtool/builtin-check.c
@@ -29,7 +29,7 @@
 #include "builtin.h"
 #include "check.h"
 
-bool no_fp, no_unreachable, retpoline, module;
+bool no_fp, no_unreachable, retpoline, module, no_kpatch;
 
 static const char * const check_usage[] = {
 	"objtool check [<options>] file.o",
@@ -48,6 +48,7 @@ int cmd_check(int argc, const char **argv)
 {
 	const char *objname;
 
+	no_kpatch = 1;
 	argc = parse_options(argc, argv, check_options, check_usage, 0);
 
 	if (argc != 1)
diff --git a/tools/objtool/builtin-coverage.c b/tools/objtool/builtin-coverage.c
new file mode 100644
index 0000000..1fc0931
--- /dev/null
+++ b/tools/objtool/builtin-coverage.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015-2017 Josh Poimboeuf <jpoimboe@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * objtool coverage:
+ *
+ * This command analyzes every .o file and ensures the validity of its stack
+ * trace metadata.  It enforces a set of rules on asm code and C inline
+ * assembly code so that stack traces can be reliable.
+ *
+ * For more information, see tools/objtool/Documentation/stack-validation.txt.
+ */
+
+#include <subcmd/parse-options.h>
+#include "builtin.h"
+#include "coverage.h"
+
+bool no_fp, no_unreachable, retpoline, module, is_coverage, no_kpatch;
+
+static const char * const coverage_usage[] = {
+	"objtool coverage [<options>] file.o",
+	NULL,
+};
+
+const struct option coverage_options[] = {
+	OPT_BOOLEAN('f', "no-fp", &no_fp, "Skip frame pointer validation"),
+	OPT_BOOLEAN('u', "no-unreachable", &no_unreachable, "Skip 'unreachable instruction' warnings"),
+	OPT_BOOLEAN('r', "retpoline", &retpoline, "Validate retpoline assumptions"),
+	OPT_BOOLEAN('m', "module", &module, "Indicates the object will be part of a kernel module"),
+	OPT_BOOLEAN('e', "no-kpatch", &no_kpatch, "Indicates the object wont be a part of kpatch"),
+	OPT_END(),
+};
+
+int cmd_coverage(int argc, const char **argv)
+{
+	const char *objname;
+
+	argc = parse_options(argc, argv, coverage_options, coverage_usage, 0);
+
+	if (argc != 1)
+		usage_with_options(coverage_usage, coverage_options);
+
+	objname = argv[0];
+
+	is_coverage = 1;
+
+	return coverage(objname);
+}
diff --git a/tools/objtool/builtin.h b/tools/objtool/builtin.h
index 28ff40e..76c6667 100644
--- a/tools/objtool/builtin.h
+++ b/tools/objtool/builtin.h
@@ -20,9 +20,10 @@
 #include <subcmd/parse-options.h>
 
 extern const struct option check_options[];
-extern bool no_fp, no_unreachable, retpoline, module;
+extern bool no_fp, no_unreachable, retpoline, module, is_coverage, no_kpatch;
 
 extern int cmd_check(int argc, const char **argv);
+extern int cmd_coverage(int argc, const char **argv);
 extern int cmd_orc(int argc, const char **argv);
 
 #endif /* _BUILTIN_H */
diff --git a/tools/objtool/check.c b/tools/objtool/check.c
index f4a25bd..f2d69fc 100644
--- a/tools/objtool/check.c
+++ b/tools/objtool/check.c
@@ -36,15 +36,55 @@ struct alternative {
 const char *objname;
 struct cfi_state initial_func_cfi;
 
+static void clear_insn_state(struct insn_state *state);
+
 struct instruction *find_insn(struct objtool_file *file,
 			      struct section *sec, unsigned long offset)
 {
 	struct instruction *insn;
+	int ret;
 
+	if (offset)
+		offset -= sec->sh.sh_addr;
 	hash_for_each_possible(file->insn_hash, insn, hash, offset)
 		if (insn->sec == sec && insn->offset == offset)
 			return insn;
 
+	insn = malloc(sizeof(*insn));
+	if (!insn) {
+		WARN("malloc failed");
+		return NULL;
+	}
+	memset(insn, 0, sizeof(*insn));
+	INIT_LIST_HEAD(&insn->alts);
+	clear_insn_state(&insn->state);
+
+	insn->sec = sec;
+	insn->offset = offset;
+
+	ret = arch_decode_instruction(file->elf, sec, offset,
+				      sec->len - offset,
+				      &insn->len, &insn->type,
+				      &insn->immediate,
+				      &insn->jcc,
+				      &insn->stack_op);
+	if (ret)
+		goto err;
+
+	if (!insn->type || insn->type > INSN_LAST) {
+		WARN_FUNC("invalid instruction type %d",
+			  insn->sec, insn->offset, insn->type);
+		goto err;
+	}
+
+	hash_add(file->insn_hash, &insn->hash, insn->offset);
+	/* FIXME(pboldin): we should add it ordered here */
+	/* list_add_tail(&insn->list, &file->insn_list); */
+
+	return insn;
+
+err:
+	free(insn);
 	return NULL;
 }
 
@@ -267,6 +307,9 @@ static int decode_instructions(struct objtool_file *file)
 		if (!(sec->sh.sh_flags & SHF_EXECINSTR))
 			continue;
 
+		if (!no_kpatch && !strstr(sec->name, "kpatch"))
+			continue;
+
 		if (strcmp(sec->name, ".altinstr_replacement") &&
 		    strcmp(sec->name, ".altinstr_aux") &&
 		    strncmp(sec->name, ".discard.", 9))
@@ -289,6 +332,7 @@ static int decode_instructions(struct objtool_file *file)
 						      sec->len - offset,
 						      &insn->len, &insn->type,
 						      &insn->immediate,
+						      &insn->jcc,
 						      &insn->stack_op);
 			if (ret)
 				goto err;
@@ -493,7 +537,7 @@ static int add_jump_destinations(struct objtool_file *file)
 	struct instruction *insn;
 	struct rela *rela;
 	struct section *dest_sec;
-	unsigned long dest_off;
+	unsigned long dest_off, offset;
 
 	for_each_insn(file, insn) {
 		if (insn->type != INSN_JUMP_CONDITIONAL &&
@@ -503,14 +547,16 @@ static int add_jump_destinations(struct objtool_file *file)
 		if (insn->ignore)
 			continue;
 
-		rela = find_rela_by_dest_range(insn->sec, insn->offset,
+		offset = insn->offset + insn->sec->sh.sh_addr;
+		rela = find_rela_by_dest_range(insn->sec,
+					       offset,
 					       insn->len);
 		if (!rela) {
 			dest_sec = insn->sec;
-			dest_off = insn->offset + insn->len + insn->immediate;
+			dest_off = offset + insn->len + insn->immediate;
 		} else if (rela->sym->type == STT_SECTION) {
 			dest_sec = rela->sym->sec;
-			dest_off = rela->addend + 4;
+			dest_off = dest_sec->sh.sh_addr + rela->addend + 4;
 		} else if (rela->sym->sec->idx) {
 			dest_sec = rela->sym->sec;
 			dest_off = rela->sym->sym.st_value + rela->addend + 4;
@@ -1197,7 +1243,7 @@ static int read_retpoline_hints(struct objtool_file *file)
 	return 0;
 }
 
-static int decode_sections(struct objtool_file *file)
+int decode_sections(struct objtool_file *file)
 {
 	int ret;
 
@@ -1219,6 +1265,9 @@ static int decode_sections(struct objtool_file *file)
 	if (ret)
 		return ret;
 
+	if (is_coverage)
+		return 0;
+
 	ret = add_special_section_alts(file);
 	if (ret)
 		return ret;
@@ -2139,7 +2188,7 @@ static int validate_reachable_instructions(struct objtool_file *file)
 	return 0;
 }
 
-static void cleanup(struct objtool_file *file)
+void cleanup(struct objtool_file *file)
 {
 	struct instruction *insn, *tmpinsn;
 	struct alternative *alt, *tmpalt;
diff --git a/tools/objtool/check.h b/tools/objtool/check.h
index c6b68fc..9615061 100644
--- a/tools/objtool/check.h
+++ b/tools/objtool/check.h
@@ -51,6 +51,7 @@ struct instruction {
 	struct instruction *first_jump_src;
 	struct list_head alts;
 	struct symbol *func;
+	struct jump_op jcc;
 	struct stack_op stack_op;
 	struct insn_state state;
 	struct orc_entry orc;
@@ -68,6 +69,8 @@ int check(const char *objname, bool orc);
 
 struct instruction *find_insn(struct objtool_file *file,
 			      struct section *sec, unsigned long offset);
+int decode_sections(struct objtool_file *file);
+void cleanup(struct objtool_file *file);
 
 #define for_each_insn(file, insn)					\
 	list_for_each_entry(insn, &file->insn_list, list)
diff --git a/tools/objtool/coverage.c b/tools/objtool/coverage.c
new file mode 100644
index 0000000..5d439f5
--- /dev/null
+++ b/tools/objtool/coverage.c
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2015-2017 Josh Poimboeuf <jpoimboe@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "builtin.h"
+#include "check.h"
+#include "coverage.h"
+#include "elf.h"
+#include "special.h"
+#include "arch.h"
+#include "warn.h"
+
+#include <linux/hashtable.h>
+#include <linux/kernel.h>
+
+static int print_jump_instruction_dynamic(struct section *sec,
+					  struct instruction *insn)
+{
+	bool is_ref = insn->jcc.dynamic_reg & JUMP_OP_DYNAMIC_REG_REF;
+	bool is_sib = insn->jcc.dynamic_sib_mult;
+	unsigned char reg = insn->jcc.dynamic_reg & ~JUMP_OP_DYNAMIC_REG_REF;
+
+	if (insn->jcc.opcode != JUMP_OP_OPCODE_DYNAMIC) {
+		WARN("dynamic jump with opcode != %x", JUMP_OP_OPCODE_DYNAMIC);
+		return -1;
+	}
+
+	if (!is_ref) {
+		printf("*%d", insn->jcc.dynamic_reg);
+		return 0;
+	}
+
+	if (!is_sib) {
+		printf("*0x%x(%d)", insn->jcc.dynamic_disp32, reg);
+		return 0;
+	}
+
+	printf("*0x%x(%d, %d, %d)",
+	       insn->jcc.dynamic_disp32,
+	       reg,
+	       insn->jcc.dynamic_sib_reg,
+	       insn->jcc.dynamic_sib_mult);
+
+	return 0;
+}
+
+#define PRINT_ABSOLUTE
+
+static int print_jump_instruction(struct section *sec, struct instruction *insn)
+{
+#ifdef PRINT_ABSOLUTE
+	printf("0x%x\t0x%016lx+0x%08x\t",
+	       insn->jcc.opcode,
+	       sec->sh.sh_addr + insn->offset,
+	       insn->len);
+#else
+	printf("0x%x\t%s+0x%016lx+0x%08x\t",
+	       insn->jcc.opcode,
+	       sec->name,
+	       insn->offset,
+	       insn->len);
+#endif
+
+	if (insn->jump_dest) {
+		struct instruction *dest = insn->jump_dest;
+
+#ifdef PRINT_ABSOLUTE
+		printf("0x%016lx\t", dest->sec->sh.sh_addr + dest->offset);
+#else
+		printf("%s+0x%016lx\t", dest->sec->name, dest->offset);
+#endif
+	} else if (insn->type == INSN_JUMP_DYNAMIC) {
+		print_jump_instruction_dynamic(sec, insn);
+	} else {
+		return -1;
+	}
+
+	printf("\n");
+}
+
+static int validate_functions(struct objtool_file *file)
+{
+	struct section *sec;
+	struct instruction *insn;
+	int ret;
+
+	for_each_sec(file, sec) {
+		if (!(sec->sh.sh_flags & SHF_EXECINSTR))
+			continue;
+
+		if (!no_kpatch && !strstr(sec->name, "kpatch"))
+			continue;
+
+		sec_for_each_insn(file, sec, insn) {
+			switch (insn->type) {
+			case INSN_JUMP_CONDITIONAL:
+			case INSN_JUMP_UNCONDITIONAL:
+			case INSN_JUMP_DYNAMIC:
+				break;
+			default:
+				continue;
+			}
+
+			ret = print_jump_instruction(sec, insn);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int coverage(const char *_objname)
+{
+	struct objtool_file file;
+	int ret, warnings = 0;
+
+	objname = _objname;
+
+	file.elf = elf_open(objname, O_RDONLY);
+	if (!file.elf)
+		return 1;
+
+	INIT_LIST_HEAD(&file.insn_list);
+	hash_init(file.insn_hash);
+	file.whitelist = find_section_by_name(file.elf, ".discard.func_stack_frame_non_standard");
+	file.rodata = find_section_by_name(file.elf, ".rodata");
+	file.c_file = find_section_by_name(file.elf, ".comment");
+	file.ignore_unreachables = no_unreachable;
+	file.hints = false;
+
+	ret = decode_sections(&file);
+	if (ret < 0)
+		goto out;
+	warnings += ret;
+
+	if (list_empty(&file.insn_list))
+		goto out;
+
+	ret = validate_functions(&file);
+	if (ret < 0)
+		goto out;
+	warnings += ret;
+
+out:
+	cleanup(&file);
+
+	/* ignore warnings for now until we get all the code cleaned up */
+	if (ret || warnings)
+		return 0;
+	return 0;
+}
diff --git a/tools/objtool/coverage.h b/tools/objtool/coverage.h
new file mode 100644
index 0000000..30f13ab
--- /dev/null
+++ b/tools/objtool/coverage.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2017 Josh Poimboeuf <jpoimboe@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _COVERAGE_H
+#define _COVERAGE_H
+
+#include <stdbool.h>
+#include "elf.h"
+#include "cfi.h"
+#include "arch.h"
+#include "orc.h"
+#include <linux/hashtable.h>
+
+int coverage(const char *objname);
+
+#endif /* _COVERAGE_H */
diff --git a/tools/objtool/elf.c b/tools/objtool/elf.c
index 7ec85d5..2b17586 100644
--- a/tools/objtool/elf.c
+++ b/tools/objtool/elf.c
@@ -353,6 +353,9 @@ static int read_relas(struct elf *elf)
 			continue;
 
 		sec->base = find_section_by_name(elf, sec->name + 5);
+		if (!sec->base && !strcmp(sec->name, ".rela.dyn"))
+			continue;
+
 		if (!sec->base) {
 			WARN("can't find base section for rela section %s",
 			     sec->name);
diff --git a/tools/objtool/objtool.c b/tools/objtool/objtool.c
index 07f3299..ac6933c 100644
--- a/tools/objtool/objtool.c
+++ b/tools/objtool/objtool.c
@@ -47,6 +47,7 @@ static const char objtool_usage_string[] =
 static struct cmd_struct objtool_cmds[] = {
 	{"check",	cmd_check,	"Perform stack metadata validation on an object file" },
 	{"orc",		cmd_orc,	"Generate in-place ORC unwind tables for an object file" },
+	{"coverage",	cmd_coverage,	"Generate in-place ORC unwind tables for an object file" },
 };
 
 bool help;
